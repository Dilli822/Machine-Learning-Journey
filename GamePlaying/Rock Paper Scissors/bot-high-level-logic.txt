
ğŸ¤– 1. quincy â€“ Pattern-Based Bot
def quincy(prev_play, counter=[0]):
    counter[0] += 1
    choices = ["R", "R", "P", "P", "S"]
    return choices[counter[0] % len(choices)]
ğŸ” Explanation:
counter=[0]: Uses a mutable default argument to keep count across calls (acts like a static variable).

counter[0] += 1: Increments the counter every time the function is called.

choices = ["R", "R", "P", "P", "S"]: A hard-coded repeating pattern of moves.

choices[counter[0] % len(choices)]: Loops through the pattern in a cycle.

ğŸ“Œ Strategy:
Plays in a fixed, repeating pattern: R â†’ R â†’ P â†’ P â†’ S â†’ R â†’ R ...

ğŸ¤– 2. mrugesh â€“ Frequency Counter Bot
def mrugesh(prev_opponent_play, opponent_history=[]):
    opponent_history.append(prev_opponent_play)
    last_ten = opponent_history[-10:]
    most_frequent = max(set(last_ten), key=last_ten.count)

    if most_frequent == '':
        most_frequent = "S"

    ideal_response = {'P': 'S', 'R': 'P', 'S': 'R'}
    return ideal_response[most_frequent]
ğŸ” Explanation:
opponent_history=[]: Keeps track of the opponent's past moves.

opponent_history.append(prev_opponent_play): Records the opponent's latest move.

last_ten = opponent_history[-10:]: Focuses only on the last 10 moves.

most_frequent = max(set(last_ten), key=last_ten.count): Finds the most commonly played move in the last 10.

if most_frequent == '': most_frequent = 'S': If there's no data, assume "S".

ideal_response = {'P': 'S', 'R': 'P', 'S': 'R'}: Dictionary to counter the most frequent move.

return ideal_response[most_frequent]: Returns the move that beats the frequent one.

ğŸ“Œ Strategy:
Learns and counters your most frequent recent move.

ğŸ¤– 3. kris â€“ Last-Move Counter Bot
def kris(prev_opponent_play):
    if prev_opponent_play == '':
        prev_opponent_play = "R"
    ideal_response = {'P': 'S', 'R': 'P', 'S': 'R'}
    return ideal_response[prev_opponent_play]
ğŸ” Explanation:
If no previous move (first round), assume "R".

Uses ideal_response to counter the last move.

ğŸ“Œ Strategy:
Assumes you'll repeat your last move, so it always counters your previous play.

ğŸ¤– 4. abbey â€“ Sequence Prediction Bot
def abbey(prev_opponent_play,
          opponent_history=[],
          play_order=[{
              "RR": 0, "RP": 0, "RS": 0,
              "PR": 0, "PP": 0, "PS": 0,
              "SR": 0, "SP": 0, "SS": 0,
          }]):
ğŸ” Part-by-Part:
    if not prev_opponent_play:
        prev_opponent_play = 'R'
Sets a default move on the first round.

python
    opponent_history.append(prev_opponent_play)
Remembers what the opponent played last.

python
    last_two = "".join(opponent_history[-2:])
Gets the last 2 moves in sequence (e.g., "RP").

python
    if len(last_two) == 2:
        play_order[0][last_two] += 1
Increments the frequency of that 2-move pattern.

python
    potential_plays = [
        prev_opponent_play + "R",
        prev_opponent_play + "P",
        prev_opponent_play + "S",
    ]
Forms 3 possible future patterns like "RR", "RP", "RS" based on current state.

python
    sub_order = {
        k: play_order[0][k]
        for k in potential_plays if k in play_order[0]
    }
Filters known transitions for scoring.

python
    prediction = max(sub_order, key=sub_order.get)[-1:]
Picks the most likely next move based on historical frequency.

python
    ideal_response = {'P': 'S', 'R': 'P', 'S': 'R'}
    return ideal_response[prediction]
Returns the move that counters the predicted move.

ğŸ“Œ Strategy:
Learns from two-move sequences to predict the most likely next move and counter it.

ğŸ§‘ 5. human â€“ Interactive User
python
def human(prev_opponent_play):
    play = ""
    while play not in ['R', 'P', 'S']:
        play = input("[R]ock, [P]aper, [S]cissors? ")
        print(play)
    return play
ğŸ” Explanation:
Keeps asking the human player for input until a valid option is entered.

Returns the human's move.

ğŸ“Œ Strategy:
Human-controlled, user types their move.

ğŸ² 6. random_player â€“ Random Strategy
python
def random_player(prev_opponent_play):
    return random.choice(['R', 'P', 'S'])
ğŸ” Explanation:
Uses Pythonâ€™s random.choice() to return any of the three moves at random.

Ignores the previous move.

ğŸ“Œ Strategy:
Completely unpredictable, chooses each move with equal probability.

âœ… Summary Table
Bot	Strategy Description
Quincy	Cycles through a fixed pattern: R â†’ R â†’ P â†’ P â†’ S
Mrugesh	Tracks last 10 opponent moves, counters the most frequent
Kris	Counters your most recent move
Abbey	Learns 2-move patterns, predicts next move, and counters it
Human	Manual input
Random	Plays a random move every round
