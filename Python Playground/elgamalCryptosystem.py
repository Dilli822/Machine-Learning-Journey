from sympy import isprime, totient
from math import gcd
import random

# Function to randomly select a prime number from a given range
def random_prime(min_num, max_num):
    primes = [num for num in range(min_num, max_num + 1) if isprime(num)]
    if not primes:
        raise ValueError(f"No prime numbers found in the range {min_num}-{max_num}")
    return random.choice(primes)

# Function to randomly select any number from a given range
def random_any_number(min_num, max_num):
    return random.randint(min_num, max_num)

# Example usage

# Random prime number selection from the range 10 to 50
prime_number = random_prime(10, 50)
print(f"Randomly selected prime number: {prime_number}")

# Random number selection from the range 10 to 50
any_number = random_any_number(10, 50)
print(f"Randomly selected any number: {any_number}")

roots = []

# Function for modular exponentiation
def mod_exp(base, exp, mod):
    return pow(base, exp, mod)

# Function to check if a number is prime
def check_prime(n):
    return isprime(n)

# Function to calculate all primitive roots modulo p
def find_primitive_roots(p):
    if not check_prime(p):
        raise ValueError(f"{p} is not a prime number. Cannot find primitive roots.")
    required_set = {num for num in range(1, p)}  # Set of elements 1 to p-1
    
    # Loop over all possible candidates for primitive roots
    for g in range(2, p):
        actual_set = {mod_exp(g, powers, p) for powers in range(1, p)}
        if required_set == actual_set:  # Check if the set generated by g covers all numbers from 1 to p-1
            roots.append(g)
    
    return roots

# Main function to check primality and find primitive roots
def check_prime_and_find_roots(n):
    if check_prime(n):
        print(f"{n} is a prime number.")
        roots = find_primitive_roots(n)
        print(f"Primitive roots of {n} are: {roots}")
    else:
        print(f"{n} is a composite number.")

# Example usage with GF(19)
number = 17
check_prime_and_find_roots(number)


def text_to_numbers(text):
    # Convert text to uppercase and ignore non-alphabet characters
    text = text.upper()
    result = []
    
    for char in text:
        if 'A' <= char <= 'Z':  # Ensure the character is a letter
            result.append(ord(char) - ord('A') + 1)
    
    return result

# Example usage
input_text = "Hi"
converted = text_to_numbers(input_text)
print(f"The text '{input_text}' converted to numbers is: {converted}")


# alpha = random.choice(list(roots))
# q = prime_number
# X_A = any_number
# uncomment to use random prime numbers and private key for robustness
alpha = 10
q = 19
X_A = 5

def generateY_A():
    return pow(alpha, X_A, q) 
    # return alpha^X_A mod q

Y_A = generateY_A()
public_key = [q, Y_A, X_A]
print(public_key)

for public_keyItems in public_key:
    # print(public_keyItems)
    pass


# USER B Now use USER A public key and encrypts the Message HI
# userB_K = random.randint(2, 100)
userB_K = 6
print(userB_K)

C1 = pow(alpha, userB_K, q)
print("Cipher_1 is ", C1)

# CIPHER 2 IS DYNAMIC
userB_K_new = pow(Y_A, userB_K, q)
print("userB_Knew", userB_K_new)

# Message h = 8 so 
M = 17
C2 = (userB_K_new * M) % q
print("C1, C2 :", C1, C2)

# USER A RECEIVED MESSAGE AS C1 AND C2
# DECRYPTION USING PRIVATE KEY

K_A = C1 ** X_A % q
print(K_A)

K_inverse = pow(K_A,-1, q)
print(K_inverse)

final_DecryptMsg = C2 * K_inverse % q
print("Final DecryptMsg", final_DecryptMsg)